# Makefile generated by imake - do not edit!
# $Xorg: imake.c,v 1.6 2001/02/09 02:03:15 xorgcvs Exp $

# ----------------------------------------------------------------------
# Makefile generated from "Imake.tmpl" and </tmp/IIf.MWWHqH>
# $XConsortium: Imake.tmpl,v 1.224.1.1 95/06/19 17:51:01 gildea Exp $
#

# emptyrule is needed to avoid picking a default rule from
# included files. This forces the user to always specify a target.  I
# think this is a good thing, but others may disagree.  If you want a
# default target, then change it here.

emptyrule::

# This file always uses the installed system utilities.  To
# override, use site.p-def.

.SUFFIXES: .i

# $XConsortium: Imake.cf,v 1.19 95/01/05 19:24:32 kaleb Exp $

# -----------------------------------------------------------------------
# site-specific configuration parameters that need to come before
# the platform-specific parameters - edit site.def to change

# site:  $Kamioka: site.sample,v 1.9 94/04/08 17:02:06 rws Exp $

# These config files require GNUmake.

# -----------------------------------------------------------------------
# platform-specific configuration parameters - edit linux.cf to change

# platform:  $XConsortium: linux.cf,v 1.11 95/01/23 18:32:03 kaleb Exp $
# $Id: Makefile,v 1.1.1.1 2016/11/04 20:31:19 mdunkman Exp $

# Define the linux threads libraries.

# $XConsortium: lnxLib.rules,v 1.8 95/01/16 21:11:00 kaleb Exp $

# -----------------------------------------------------------------------
# site-specific configuration parameters that go after
# the platform-specific parameters - edit site.def to change

# site:  $Kamioka: site.sample,v 1.9 94/04/08 17:02:06 rws Exp $

SITE_LDOPTIONS += -L/usr/X11R6/lib64

SITE_DEFINES += -DUSE_STDARG -g -O0

SITE_INCLUDES += -I/usr/include
SITE_INCLUDES += -I${CERN}/${CERN_LEVEL}/include

SITE_LIBRARIES += -lm

# -----------------------------------------------------------------------
# These may be set in Package.def, or Project.def.  These are used
# to make sure that the "make Makefile" command works correctly.
      BOOT_DEFINES =
     BOOT_INCLUDES =

# -----------------------------------------------------------------------
# This is the command line from imake_boot
COMMAND_LINE = -DREDHAT

# -----------------------------------------------------------------------
# Set the defaults for the current package being compiled.  The
# package is set on the command line with "imake_boot -Dpackage"

# ----------------------------------------------------------------------
# Customize for the Super-Kamiokande detector.
# ----------------------------------------------------------------------

# -----------------------------------------------------------------------
# Set the defaults for the current project being compiled.

   BOOT_DEFINES += -DSKAM=1
   EXPERIMENT_DEFINES += -DSKAM=1

# -----------------------------------------------------------------------
# Fill all of the options that could have been set in site.def or
# the .cf file with default values.

 _NULLCMD_ = @ echo -n

# -----------------------------------------------------------------------
# Set the machine dependent variables.
ifeq ($(strip $(MACHINE)),)
  ifeq ($(strip $(MACHINE_DIR)),)
     MACHINE=unknown
  else
     MACHINE=$(MACHINE_DIR)
  endif
endif

# Set the prefix for machine dependent files.  This is mostly for
# object files, but libraries and executables are prepended with
# OBJPREFIX.
        OBJPREFIX = $(MACHINE)/

#

# -----------------------------------------------------------------------
# Allow Imake.rules rules to be overridden.

# Include the standard Imake.rules.

# -----------------------------------------------------------------------
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.197.1.1 95/06/19 18:01:48 gildea Exp $

# Here is a summary of the "normal" targets.  Almost everything
# can be done with these targets.  If you don't see what you need, the
# ask an expert since there's probably an easy way to do it.
#
#   "NormalLibraryTarget	(libname,objlist)"
#
#	Build a library from a list of objects.  The library name is
#	the name that is used in a -l statement:
#	example: to build libsk.a
#		"NormalLibraryTarget(sk,$(OBJS))"
#
#   "NormalProgramTarget(program,objects,deplibs,locallibs,syslibs)"
#
#	Compile and link a program from objects.  The deplibs should
#	usually be empty. The locallibs and syslibs are the list of
#   libraries to use.
#   example:  to compile fitit from fitit.F, now.c, libsk.a and
#		cernlib.
#		"NormalProgramTarget(fitit,fitit.o now.o,,-lsk `cernlib`,)"
#
#   "NormalFortranProgramTarget(program,objects,deplibs,locallibs,syslibs)"
#
#	Used under certain rare circumstances where
#	NormalProgramTarget just won't do.  Please try
#	NormalProgramTarget first and bug the imake configuration
#	manager to make it work.
#
#   "InstallProgram		(program,dest)"
#   "InstallScript		(script,dest)"
#   "InstallLibrary		(libname,dest)"
#   "InstallInclude		(file,dest)"
#   "InstallManPage		(file,dest)"
#   "InstallNonExecFile	(file,dest)"
#
#   Install files out of the source tree.  Any "final" target like
#   a library or user program should be installed.  By default
#   installs go into PRIVATE_ROOT.  The library manager will make
#	installs into the group area.
#
#   "DependTarget		()"
#   "MakeScriptFromCpp	(name,defs)"
#   "AllTarget		(depends)"

# ---------------------------------------------------------------
# Lots of useful macros to help build rules.

# -------------------------------------------------------------
# Helpers to place objects in a machine dependent sub directory.

# The list of objects to not add a prefix to.

# Take an object list and prepend the necessary prefix.  This is
# used so the objects are placed into a subdirectory.  If an
# object starts with one of "ObjectAbsoluteList" then the object
# file is treated as an absolute file reference.

# Build the name of the object file that will be made as the
# target of a compile. This is used to place objects into a
# subdirectory.

# ------------------------------------------------------------------
# Ways to execute programs from a makefile. These should be used
# instead of directly executing the program.

# -------------------------------------------------------------
# Define special targets for special compilers.  These are seldom
# used and are here to deal with vendor idiosyncrasies (idiocies).
# -------------------------------------------------------------

# The last special vendor target.
# ---------------------------------------------------------------

# --------------------------------------------------------------
# Helpers to link programs.  These are used by the ProgramTargets

# ------------------------------------------------------------
# ProgramTargets.  This section has the rules to build program
# targets.

# ----------------------------------------------------------
# These are easy interfaces to the ComplexProgramTargets for
# programs that only have one file.

# ------------------------------------------------------------------
# The complex program targets.  These are MEGA targets that can
# only be used in Imakefiles that discribe a single program.  These
# should be avoided and the normalProgramTarget should be used.

# End of the Complex Program Targets.
# --------------------------------------------------------------

# --------------------------------------------------------------
# Baggage left over from X11.  This was used to build the server.

# ------------------------------------------------------------
# File installation targets.

# Always install files even if the installed file is newer.

# --------------------------------------------------------------
# Build the dependencies.

# ---------------------------------------------------------------
# Targets to rebuild the Makefile.

# NormalLibraryObjectRule - for simple libraries

$(OBJPREFIX)%.o: %.c
	@if [ -d $(OBJPREFIX) ]; 	then exit 0; 	else set -x; 	     $(MKDIR) $(patsubst %/,%,$(OBJPREFIX)); 	fi
	$(RM) $@
	$(CC) -c $(CFLAGS) $(_NOOP_) -o $@ $<

# Normal rule for C++ library objects.

$(OBJPREFIX)%.o: %.cc
	@if [ -d $(OBJPREFIX) ]; 	then exit 0; 	else set -x; 	     $(MKDIR) $(patsubst %/,%,$(OBJPREFIX)); 	fi
	$(RM) $@
	$(CXX) -c $(CXXFLAGS) $(_NOOP_) -o $@ $*.cc

# Define a target to build a lone object file.

# -------------------------------------------------------
# -------------------------------------------------------
# Rules for other types of files.
# -------------------------------------------------------
# -------------------------------------------------------

# -------------------------------------------------------------
# Define rules for kuipc
#

.SUFFIXES: .cdf

.cdf.c:
	$(KUIPC) $< $(@F)

# -------------------------------------------------------------
#  Define the rules to make the include files from the *.ch files.
#

# Rules to build CHGEN include files.

.SUFFIXES: .ch .h

%.h: %.ch
	chgen -h $*.ch > $*.h

.SUFFIXES: .ch .fh

%.fh: %.ch
	chgen -F $*.ch > $*.fh

#  GF. Add rules and target for gmake style of checking dependencies
#   950817

.SUFFIXES: .d

%.d: %.c
	$(SHELL) -ec "gcc -M $(ALLDEFINES) $< \
                      | sed 's/^[ ]*$*\.o/& $@/g' >$@"

%.d: %.F
	$(TOUCH) $@.tmp
	$(SHELL) -ec 'makedepend -f$@.tmp  -- $(ALLDEFINES) $<'
	$(SHELL) -ec sed 's/^[ ]*$*\.o/& $@/g' $@.tmp >$@
	$(RM)  $@.tmp*

# -------------------------------------------------------------
# Targets to build recusively down a subdirectory tree.

# Some extra rules if we have fortran.

    FORTRAN_RULES = <fortran.rules>

# Fortran... Just say no

.SUFFIXES: .F

$(OBJPREFIX)%.o: %.F
	@if [ -d $(OBJPREFIX) ]; 	then exit 0; 	else set -x; 	     $(MKDIR) $(patsubst %/,%,$(OBJPREFIX)); 	fi
	$(RM) $@
	$(FC) -c $(FCFLAGS) -o $@ $<

$(OBJPREFIX)%.o: %.f
	@if [ -d $(OBJPREFIX) ]; 	then exit 0; 	else set -x; 	     $(MKDIR) $(patsubst %/,%,$(OBJPREFIX)); 	fi
	$(RM) $@
	$(FC) -c $(FCFLAGS) -o $@ $<

debug::
	@echo PACKAGE_INCLUDES= $(PACKAGE_INCLUDES)
	@echo ALLINCLUDES=$(ALLINCLUDES)
	@echo ALLDEFINES=$(ALLDEFINES)
	@echo FORTRANALLDEFINES=$(FORTRANALLDEFINES)

# ********************************************************************
# If Imakefiles are allowed to use the special cernlib targets,
# then define "ALLOW_SPECIAL_CERNLIB_TARGETS"
# ********************************************************************

# ********************************************************************
# If you want to use the cern big library rules, then define
# "USE_BIG_LIB_RULES".
# ********************************************************************

# The config files that might change and require the Makefile to
# be rebuilt.

     ICONFIGFILES = $(IRULESRC)/Imake.tmpl 			$(IRULESRC)/Project.tmpl 			$(IRULESRC)/site.def 			$(IRULESRC)/$(MACROFILE) 			$(IRULESRC)/defaults.tmpl 			$(IRULESRC)/Imake.rules 			$(IRULESRC)/commands.tmpl 			$(IRULESRC)/macros.tmpl 			$(IRULESRC)/paths.tmpl 			$(IRULESRC)/Threads.tmpl 			 $(EXTRA_ICONFIGFILES)

# Force the shell.

            SHELL = /bin/sh

# Define the AR command.

                AR = ar clq

# Define the XARGS command.

	    XARGS = xargs

# The cpp command

              CPP = /lib/cpp $(STD_CPP_DEFINES)

# Define the C compiler.

               CC = gcc -fPIC -fpcc-struct-return -Wall -Wno-unused -g
ifeq ($(strip $(CDEBUGFLAGS)),)
      CDEBUGFLAGS = -O2 -fno-strength-reduce 				-fomit-frame-pointer
endif
        CCOPTIONS =

# The C++ definitions.

.SUFFIXES: .cc

              CXX = g++ -Wall
    CXXDEBUGFLAGS = -O2 -fno-strength-reduce 				-fomit-frame-pointer
 CXXEXTRA_DEFINES =
CXXEXTRA_INCLUDES =
  CXXIDL_INCLUDES = -I$(TOP)/include
   CXXSTD_DEFINES = -Dlinux -D__i386__ -D_POSIX_SOURCE -D_BSD_SOURCE -D_GNU_SOURCE -DX_LOCALE -Df2cFortran -DStrictF77 -DREDHAT
       CXXOPTIONS = -fPIC
      CXXINCLUDES = $(INCLUDES) $(TOP_INCLUDES) $(CXXEXTRA_INCLUDES) $(CXXIDL_INCLUDES)
       CXXDEFINES = $(CXXINCLUDES) $(CXXSTD_DEFINES) $(THREADS_CXXDEFINES) $(CXXEXTRA_DEFINES)
         CXXFLAGS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(THREADS_CXXFLAGS) $(CXXDEFINES)

# Here we set up flags needed to produce position-independent code
# when doing C and C++ compilation.  The default if you specify C
# PIC flags without also specifying C++ PIC flags is to assume that
# the C flags work for both.  If your C++ compiler requires different
# flags, specify them explicitly in -fPIC.

    SHAREDCODEDEF =
         SHLIBDEF =

     SHLIBLDFLAGS = -shared

         PICFLAGS = -fPIC

      CXXPICFLAGS = -fPIC

      PIFFLAGS = -fPIC

# The fortran compiler.

               FC = g77
              FPP = /lib/cpp
      FDEBUGFLAGS = -O -g
FORTRANSAVEOPTION =
   FORTRANOPTIONS = -fPIC -fno-backslash -fno-automatic -finit-local-zero       -fno-second-underscore -fugly-complex -ffixed-line-length-132        -fno-globals -fdollar-ok  -ffortran-bounds-check $(FORTRANSAVEOPTION)
           FCLINK = g77
  FORTRANLIBRARIES = -lg2c -lm
   FORTRANDEFINES =
FORTRANALLDEFMDEPEND = $(FORTRANINCLUDES) 			$(FORTRANDEFINES) 			$(ALLDEFINES)

  FORTRANALLDEFINES = $(FORTRANALLDEFMDEPEND)

          FCFLAGS = $(FDEBUGFLAGS) $(FCOPTIONS) $(FORTRANOPTIONS) $(FORTRANALLDEFINES)

# The assembler.

               AS = as

# The compress command.

         COMPRESS = compress

# The preprocessor command.

    PREPROCESSCMD = gcc -fPIC -fpcc-struct-return -Wall -Wno-unused -g -E $(STD_CPP_DEFINES)

# The set of normal CPP defines.

        CCDEFINES =

# The include files paths and nessary "special" files.

     STD_INCLUDES =
  STD_CPP_DEFINES = -Dlinux -D__i386__ -D_POSIX_SOURCE -D_BSD_SOURCE -D_GNU_SOURCE -DX_LOCALE -Df2cFortran -DStrictF77 -DREDHAT
      STD_DEFINES = -Dlinux -D__i386__ -D_POSIX_SOURCE -D_BSD_SOURCE -D_GNU_SOURCE -DX_LOCALE -Df2cFortran -DStrictF77 -DREDHAT

# The commands to make include files

	CHGEN = chgen

	INC2H = inc2h

# The commands to run kuip

        KUIPC = kuipc

# The command to install files.

          INSTALL = $(SHELL) $(CONFIGSRC)/install-sh
     INSTALLFLAGS = -c

     INSTPGMFLAGS = -s

     INSTBINFLAGS = -m 0755
     INSTUIDFLAGS = -s -m 4755
     INSTLIBFLAGS = -m 0644
     INSTINCFLAGS = -m 0444
     INSTMANFLAGS = -m 0444
     INSTDATFLAGS = -m 0444
    INSTKMEMFLAGS = -s -m 4755

# The loader command.  This links programs.

               LD = ld

# The load options.

         LDPRELIB =
        LDPOSTLIB =
 EXTRA_LOAD_FLAGS =
  EXTRA_LDOPTIONS =
  EXTRA_LIBRARIES = $(FORTRANLIBRARIES)
     LDSTRIPFLAGS = -x
   LDCOMBINEFLAGS = -r

# The lex command.

              LEX = flex -l
           LEXLIB = -lfl

# The yacc command

             YACC = bison -y
          YACCLIB =
           CCYACC = bison -y

# The lint command for those that must.

             LINT = lint
      LINTLIBFLAG = -C
         LINTOPTS = -axz
       LINTLIBDIR = $(USRLIBDIR)/lint

# The copy command.

               CP = cp

# The command to make a link.  Can also be cp instead of ln.

               LN = ln -s

# The make command.

             MAKE = make

# The command to move a file.

               MV = mv

# The command to run ranlib (if it is necessary).

           RANLIB = ranlib
  RANLIBINSTFLAGS =

# The touch command

            TOUCH = touch

# The remove command and the files to clean.

               RM = rm -f
           RM_CMD = $(RM)

# The command to run the stream editor.

              SED = sed

# The command to run the tr command.

               TR = tr

# The command to generate tags.

             TAGS = ctags

# The command to run Imake.

ifeq "$(strip $(IMAKE))" ""
            IMAKE = imake
endif
# These are for command line or Imakefile use.
    IMAKE_DEFINES = -DCMDLINE="$(COMMAND_LINE)" $(COMMAND_LINE)
    IMAKE_INCLUDES=

# Where to search for the config files.  This provides ways to
# override the default config files.  The package can override the
# config files by using ./config or $(TOP)/config.  The user can
# override the package config files by using "." or
# "$(HOME)/config".  Everything can be overriden by using
# $(IMAKE_INCLUDES)
    IMAKE_PATHS = $(IMAKE_INCLUDES) $(BOOT_INCLUDES) 	-I. -I$(HOME)/config 	-I./config -I$(TOP) -I$(TOP)/config 	-I$(IRULESRC)

# Build the default imake command.

         IRULESRC = $(CONFIGDIR)
        IMAKE_CMD = $(IMAKE) -DUseInstalled -DLocalTop=$(LOCALTOP) 			 			$(IMAKE_PATHS) $(BOOT_DEFINES) $(IMAKE_DEFINES)

# Funky definition left over from the original Imake
# distribution.  Needed if these config files ever have to build the
# imake executable.
  BOOTSTRAPCFLAGS =

# The command to build the depends.

ifeq "$(strip $(MAKEDEPEND))" ""
           DEPEND = makedepend
else
	   DEPEND = $(MAKEDEPEND)
endif
      DEPENDFLAGS = -p$(OBJPREFIX)

           IXXSRC = $(UNSUPPORTEDSRC)/programs/ixx
              IXX = ixx
         IXXFLAGS = -s BaseObject -m TypeObj -r RequestObj -p Xf
      IXXINCLUDES = -i '<X11/Fresco/enter-scope.h>'

        MKDIRHIER = mkdirhier

	MKDIR = mkdir -p

            TROFF = psroff
         MSMACROS = -ms
              TBL = tbl
              EQN = eqn

            DVIPS = dvips
            LATEX = latex

# Specify how to link C and C++

           CCLINK = $(CC)

          CXXLINK = $(CXX)

# The following supports forcing of function prototypes

    PROTO_DEFINES = -DFUNCPROTO=15 -DNARROWPROTO

#  STD_INCLUDES contains system-specific includes
#  TOP_INCLUDES specifies how to get to /usr/include or
#               its build substitute
#  PACKAGE_INCLUDES gives include files for a given working-group.
#  EXPERIMENT_INCLUDES are project-specific includes set in
#               project incfiles
#  SITE_INCLUDES are defined in site.def
#  INCLUDES are client-specific includes set in Imakefile
      ALLINCLUDES = $(INCLUDES) 		$(PACKAGE_INCLUDES) 		$(EXPERIMENT_INCLUDES) 		$(SITE_INCLUDES) 		$(TOP_INCLUDES) 		$(STD_INCLUDES)

  FORTRANINCLUDES = $(PACKAGE_FORTRAN_INCLUDES) 			$(EXPERIMENT_FORTRAN_INCLUDES)

# STD_DEFINES are system-specific defines (set in .cf)
# EXPERIMENT_DEFINES are project-specific defines (set in
#		Project.tmpl)
# PACKAGE_DEFINES are working-group specific defines.
# SITE_DEFINES are defined in site.def.
# EXPERIMENTDEFINES are the machine type and system type for vender.cf
# DEFINES is set in the Imakefile.
# The other _DEFINES are internal to Imake.
       ALLDEFINES = $(ALLINCLUDES) 		$(STD_DEFINES) 		$(SITE_DEFINES) 		$(EXPERIMENT_DEFINES) 		$(PACKAGE_DEFINES) 		$(PROTO_DEFINES) 		$(THREADS_DEFINES) 		$(EXTRA_DEFINES) 		$(DEFINES) 		$(CCDEFINES) 		$(EXPERIMENTDEFINES)

# The flags passed to the C compiler.  Users should use
# CDEBUGFLAGS to control debugging from the command line.
           CFLAGS = $(CDEBUGFLAGS) 			$(CCOPTIONS) 			$(THREADS_CFLAGS) 			$(ALLDEFINES)

# The flags passed to the C++ compiler.  Users should use
# CDEBUGFLAGS to control debugging from the command line.
           CXXFLAGS = $(CXXDEBUGFLAGS) 			$(CXXOPTIONS) 			$(THREADS_CFLAGS) 			$(ALLDEFINES)

# The flags passed to lint
        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES) $(DEPEND_DEFINES)

# ------------------------------------------------------------
# The flags to pass to the linker/loader.
# EXTRA_LDOPTIONS is defined in the .cf or machine specific rules file.
# LOCAL_LDFLAGS   is defined in the Imakefile.
# EXPERIMENT_LDOPTIONS is defined for the experiment in Project.tmpl
# PACKAGE_LDOPTIONS is defined for the package in Package.tmpl
# EXPERIMENT_LDPATHS is defined in paths.tmpl using EXPERIMENT_ROOT
# PACKAGE_LDPATHS is defined in paths.tmpl using PACKAGE_ROOT
# SITE_LDOPTIONS is defined in the site.def file.
# The other definitions are used internally by Imake.

PROJECT_LDOPTIONS = $(PACKAGE_LDPATHS) $(EXPERIMENT_LDPATHS) 			$(SITE_LIBRARIES) 			$(EXPERIMENT_LDOPTIONS) $(PACKAGE_LDOPTIONS) 			$(SITE_LDOPTIONS)

# For C
        LDOPTIONS = $(CDEBUGFLAGS) 			$(CCOPTIONS) 			$(EXTRA_LDOPTIONS) 			$(THREADS_LDFLAGS) 			$(PROJECT_LDOPTIONS) 			$(LOCAL_LDFLAGS) 			$(LDPRELIB)

# For C++
     CXXLDOPTIONS = $(CXXDEBUGFLAGS) 			$(CXXOPTIONS) 			$(EXTRA_LDOPTIONS) 			$(THREADS_CXXLDFLAGS) 			$(PROJECT_LDOPTIONS) 			$(LOCAL_LDFLAGS) 			$(LDPRELIB)

# For fortran.
      FCLDOPTIONS =  $(FDEBUGFLAGS) 			$(FORTRANOPTIONS) 			$(EXTRA_LDOPTIONS) 			$(THREADS_LDFLAGS) 			$(PROJECT_LDOPTIONS) 			$(LOCAL_LDFLAGS) 			$(LDPRELIB)

# The librarys that must be included.
# EXTRA_LIBRARIES is defined by "ExtraLibraries" in the .cf files.
# SITE_LIBRARIES is defined in site.def.
# SYS_LIBRARIES is a synonym for SITE_LIBRARIES
           LDLIBS = $(LDPOSTLIB) 			$(THREADS_LIBS) 			$(SITE_LIBRARIES) 			$(SYS_LIBRARIES) 			$(EXTRA_LIBRARIES)

        MACROFILE = linux.cf

# --------------------------------------------------------
# Get the package specific configuration and rules.  The package
# is a part of the project (for instance an analysis group that is part
# of an experiment).
#

# $Id: Makefile,v 1.1.1.1 2016/11/04 20:31:19 mdunkman Exp $
# Define the package defaults.  This is where the various working
# groups should define the working group defaults.  For the most part
# leave this file alone, but if the working group must make new
# definitions it should go in $(PACKAGE_TOP)/config

# --------------------------------------------------------
# get project-specific configuration and rules.  A project is the
# over all project being worked on.  For instance, an experiment.
#

# --------------------------------------------------------

EXPERIMENT_DEFINES += -DCERNLIB_TYPE

# Include a possible TMPL file for the local package.  This might
# be defined in the package template so that individual libraries in the
# package can have thier own template file.

# --------------------------------------------------------
# All of the other template files that might define paths have
# been loaded.  Now define the default set of paths.

# For the truly paranoid.  Mostly this is just being overly
# organized.  We can ignore it.

          PATHSEP = /

# The build configuration info.  $(CVSCOSRC) $(CVSCOSRC) comes from
# Project.tmpl
        CONFIGDIR = $(CVSCOSRC)

# Where the config source is kept.  This is where the default
# config files (like this one) are kept.

        CONFIGSRC = $(CVSCOSRC)
         IMAKESRC = $(CONFIGSRC)/imake

# Where the source for makedepend is kept.  This isn't used
# outside of the X11 distribution so you can safely ignore it.

        DEPENDSRC = $(CONFIGSRC)/makedepend

# A convenient definition for the other man directories.

    MANSOURCEPATH = $(MANPATH)/man

# The directory for the command manual pages.

        MANSUFFIX = 1sk
          MANDIR = $(MANSOURCEPATH)1

# The directory for the library manual pages.

     LIBMANSUFFIX = 3sk
        LIBMANDIR = $(MANSOURCEPATH)3

# The directory for the file format manual pages.

    FILEMANSUFFIX = 5sk
       FILEMANDIR = $(MANSOURCEPATH)5

# Where the system files are.

# Define the "root" on this machine.  Mostly this is not used.

      PROJECTROOT = /usr

          INCROOT = /usr/include
        USRLIBDIR = /usr/lib
         SHLIBDIR = /usr/lib

# Define the location of this directory relative to the TOP.

              TOP = /net/sukond1/export/data/hayato/t2k/neut_5.1.1_cand/src/neututils/calc_dis_crs
      CURRENT_DIR =

# ------------------------------------------------------------
# Check to see if private root is enable in the environment.  If
# it is, then query the user to make sure it's intentional.  The
# user can prevent the query by setting PRIVATE on the command
# line.
# ------------------------------------------------------------
ifneq ($(origin PRIVATE),command line)
  ifneq ($(strip $(PRIVATE_ROOT)),)
    TMP := $(shell echo "This message can be overridden by 'make PRIVATE=y'" 1>&2)
    TMP := $(shell (echo "PRIVATE_ROOT is set to $(PRIVATE_ROOT): Continue? [n]" 1>&2; read ANSWER; echo $$ANSWER))
    ifneq ($(findstring y, $(TMP)),y)
      TMP := $(shell echo "***** unset PRIVATE_ROOT then make again." 1>&2)
      TMP := $(shell echo "***** You could use 'make PRIVATE=y'" 1>&2 )
      THIS_MUST_CRASH
    endif
  endif
endif

# ------------------------------------------------------------
# The following section is set up so that a user can override the group
# directories by defining PRIVATE_ROOT.   If PRIVATE_ROOT root is
# defined, then the libraries and include files in PRIVATE_ROOT are
# searched before the group directories which allows the user to
# override the group files to test new version without interfering with
# others.  If PrivateRoot is defined in Project.tmpl or
# Package.tmpl this is used as the default value; otherwise the value
# is taken from the environment.  PRIVATE_ROOT is always overriden
# by the environment.
# ------------------------------------------------------------

ifeq ($(strip $(PRIVATE_ROOT)),)
     PRIVATE_ROOT =
endif

# ------------------------------------------------------------
# Define where the Experiment files and directories are found.
# The user is must define the environment variable EXPERIMENT before
# using make.  This environment variable holds the location of the
# experiment libraires and include files.

ifeq ($(strip $(EXPERIMENT)),)
  EXPERIMENT=${HOME}
endif
ifeq ($(strip $(EXPERIMENT_LEVEL)),)
  EXPERIMENT_LEVEL=pro
endif

# Define where the installed public experiment files are.
PUBLIC_EXPERIMENT_ROOT = $(EXPERIMENT)/$(EXPERIMENT_LEVEL)

# See if the user is overriding them with a local copy.  This can
# be done by defining PRIVATE_ROOT on the command line or as an
# environment variable.
ifneq ($(strip $(PRIVATE_ROOT)),)
  EXPERIMENT_ROOT = $(PRIVATE_ROOT)
else
  EXPERIMENT_ROOT = $(EXPERIMENT)/$(EXPERIMENT_LEVEL)
endif

# Define where to find the experiment libraries.  If PRIVATE_ROOT
# is defined then the lib directory in PRIVATE_ROOT is search
# first.
       EXPERIMENT_LIBDIR = $(EXPERIMENT_ROOT)/lib/$(MACHINE)
PUBLIC_EXPERIMENT_LIBDIR = $(PUBLIC_EXPERIMENT_ROOT)/lib/$(MACHINE)
       EXPERIMENT_OBJDIR = $(EXPERIMENT_ROOT)/obj/$(MACHINE)
PUBLIC_EXPERIMENT_OBJDIR = $(PUBLIC_EXPERIMENT_ROOT)/obj/$(MACHINE)
     EXPERIMENT_SHLIBDIR = $(PUBLIC_EXPERIMENT_ROOT)/shlib/$(MACHINE)
    EXPERIMENT_LDPATHS = -L$(EXPERIMENT_LIBDIR) 				-L$(EXPERIMENT_SHLIBDIR) 				-L$(PUBLIC_EXPERIMENT_LIBDIR)

# Define where the experiment include files are.  If PRIVATE_ROOT
# is defined then the include directory in PRIVATE_ROOT is searched
# first.
       EXPERIMENT_INCDIR = $(EXPERIMENT_ROOT)/include
PUBLIC_EXPERIMENT_INCDIR = $(PUBLIC_EXPERIMENT_ROOT)/include
     EXPERIMENT_INCLUDES = -I$(EXPERIMENT_INCDIR) 				-I$(PUBLIC_EXPERIMENT_INCDIR)

       EXPERIMENT_FORTRAN_INCDIR = $(EXPERIMENT_ROOT)/inc
PUBLIC_EXPERIMENT_FORTRAN_INCDIR = $(PUBLIC_EXPERIMENT_ROOT)/inc
     EXPERIMENT_FORTRAN_INCLUDES = -I$(EXPERIMENT_FORTRAN_INCDIR) 				-I$(PUBLIC_EXPERIMENT_FORTRAN_INCDIR)

# Define where the experiment binary files are.  This is mostly
# used to install programs.  If PRIVATE_ROOT is defined the it overrides
# the group directories.
       EXPERIMENT_BINDIR = $(EXPERIMENT_ROOT)/bin/$(MACHINE)
PUBLIC_EXPERIMENT_BINDIR = $(PUBLIC_EXPERIMENT_ROOT)/bin/$(MACHINE)

# Define where the experiment script files are.  This is mostly
# used to install programs.  If PRIVATE_ROOT is defined the it overrides
# the group directories.
       EXPERIMENT_SCRIPTDIR = $(EXPERIMENT_ROOT)/bin
PUBLIC_EXPERIMENT_SCRIPTDIR = $(PUBLIC_EXPERIMENT_ROOT)/bin

# ------------------------------------------------------------
# Define where the working group files and directories are.  These
# can be overridden by the PRIVATE_ROOT variable.  If PACKAGE is
# not defined then it defaults to EXPERIMENT.  If you are working
# on the main expermiment libraries, then PACKAGE should be the
# same as EXPERIMENT.  Really it should only be different for something
# that won't be used the the EXPERIMENT as a whole (perhaps online
# or MC).  In SuperK, example packages are atmpd, or lowe
ifeq ($(strip $(PACKAGE)),)
  PACKAGE=$(EXPERIMENT)
endif
ifeq ($(strip $(PACKAGE_LEVEL)),)
  PACKAGE_LEVEL=new
endif

# See if the user is overriding them with a local copy.  This can
# be done by defining PRIVATE_ROOT on the command line or as an
# environment variable.
ifneq ($(strip $(PRIVATE_ROOT)),)
  PACKAGE_ROOT = $(PRIVATE_ROOT)
else
  PACKAGE_ROOT = $(PACKAGE)/$(PACKAGE_LEVEL)
endif

# Define where the installed public package files are.
PUBLIC_PACKAGE_ROOT = $(PACKAGE)/$(PACKAGE_LEVEL)

# Define where to find the package libraries.  If PRIVATE_ROOT
# is defined then the lib directory in PRIVATE_ROOT is search
# first.
        LIBDIR = $(PACKAGE_ROOT)/lib/$(MACHINE)
PACKAGE_LIBDIR = $(PUBLIC_PACKAGE_ROOT)/lib/$(MACHINE)
        OBJDIR = $(PACKAGE_ROOT)/obj/$(MACHINE)
PACKAGE_OBJDIR = $(PUBLIC_PACKAGE_ROOT)/obj/$(MACHINE)
      SHLIBDIR = $(PUBLIC_PACKAGE_ROOT)/shlib/$(MACHINE)
PACKAGE_LDPATHS = -L$(LIBDIR) 			-L$(SHLIBDIR) 			-L$(PACKAGE_LIBDIR)

# Define where the package include files are.  If PRIVATE_ROOT
# is defined then the include directory in PRIVATE_ROOT is searched
# first.
	  INCDIR = $(PACKAGE_ROOT)/include
  PACKAGE_INCDIR = $(PUBLIC_PACKAGE_ROOT)/include
PACKAGE_INCLUDES = -I. -I$(INCDIR) 			-I$(PACKAGE_INCDIR)

          FORTRAN_INCDIR = $(PACKAGE_ROOT)/inc
  PACKAGE_FORTRAN_INCDIR = $(PUBLIC_PACKAGE_ROOT)/inc
PACKAGE_FORTRAN_INCLUDES = -I. -I$(FORTRAN_INCDIR) 				-I$(PACKAGE_FORTRAN_INCDIR)

# Define where the package binary files are.  This is mostly
# used to install programs.  If PRIVATE_ROOT is defined the it overrides
# the group directories.
        BINDIR = $(PACKAGE_ROOT)/bin/$(MACHINE)
PACKAGE_BINDIR = $(PUBLIC_PACKAGE_ROOT)/bin/$(MACHINE)

# Define where the package script files are.  This is mostly
# used to install programs.  If PRIVATE_ROOT is defined the it overrides
# the group directories.
        SCRIPTDIR = $(PACKAGE_ROOT)/bin
PACKAGE_SCRIPTDIR = $(PUBLIC_PACKAGE_ROOT)/bin

# Define where the package manual files are.  If PRIVATE_ROOT is
# then it overrides the group directories.
	MANPATH = $(PACKAGE_ROOT)/man

# Define where the library of data files is found.
	DATADIR = $(PACKAGE_ROOT)/lib
 PUBLIC_DATADIR = $(PUBLIC_PACKAGE_ROOT)/lib

# Add a obsolete definition to be compadible with the old
# Imakefiles.
   COMMONLIBDIR = $(DATADIR)

# --------------------------------------------------------
# Define the Threads libraries.  If the project is not threaded, this
# is mostly a noop.

# $XConsortium: Threads.tmpl,v 1.3 94/03/30 12:04:19 gildea Exp $

    THREADS_CFLAGS =
   THREADS_DEFINES =
   THREADS_LDFLAGS =
      THREADS_LIBS = -lpthread

  THREADS_CXXFLAGS =
THREADS_CXXDEFINES =
THREADS_CXXLDFLAGS =
   THREADS_CXXLIBS =

	EXPERIMENTDEFINES=-DEXPERIMENT_LINUX -DEXPERIMENT_UNIX -DEXPERIMENT_LNX
        PACKAGETOP=
        PACKAGE_NAME=
	LOCALTOP=

	VPATH=$(PROJECTROOT)$(LOCALTOP)$(CURRENT_DIR)

OBJS_C=$(SRCS_C:.c=.o)
OBJS_F=$(SRCS_F:.F=.o)
OBJS_CDF=$(SRCS_CDF:.cdf=.o)

OBJS=$(OBJS_C) $(OBJS_CXX) $(OBJS_F) $(OBJS_CDF)

# -----------------------------------------------------------------------
# start of Imakefile : </tmp/IIf.MWWHqH>

emptyrule:: all

NEUTCOREVER	= 5.1.1
NUCEFFVER   = 5.1.0
NUCCORVER   = 1.1.0
PARTNUCKVER = 5.0.5
SKMCSVCVER  = 5.0.5

COREDIR =	../neutcore/Linux_pc
LIBDIRS =	-L${COREDIR}            -L../nuccorspl/Linux_pc 			-L../nuceff/Linux_pc -L../partnuck/Linux_pc  			-L../skmcsvc/Linux_pc

MCLIB = ${LIBDIRS} -lneutcore_${NEUTCOREVER} -lneutcore_${NEUTCOREVER} 		-lskmcsvc_${SKMCSVCVER}			-lnuceff_${NUCEFFVER} -lnuccorrspl_${NUCCORVER} 		-lpartnuck_${PARTNUCKVER} -lskmcsvc_${SKMCSVCVER}

OBJS	= tpispir.o

INCLUDES	= -I

# FDEBUGFLAGS =

.PHONY: calcapicrs

calcapicrs: $(OBJPREFIX)calcapicrs

$(OBJPREFIX)calcapicrs: $(filter -l% $(LIBDIR)%,calcapicrs.o $(OBJS))		$(addprefix $(OBJPREFIX),$(filter-out -l% $(LIBDIR)%,calcapicrs.o $(OBJS)))
	$(RM) $@
	$(FCLINK) -o $@ $(FCLDOPTIONS) $(filter -l% $(LIBDIR)%,calcapicrs.o $(OBJS))		$(addprefix $(OBJPREFIX),$(filter-out -l% $(LIBDIR)%,calcapicrs.o $(OBJS))) $(MCLIB) `cernlib geant321 graflib grafX11 packlib kernlib mathlib pdflib804` $(LDLIBS) -lX11 $(EXTRA_LOAD_FLAGS) \
	 || $(RM) $@
	@if [ ! -x $@ ] ; then set -e;	\
	 echo Error: $@ not executable;$(RM) $@;\
	 exit 1; else exit 0;fi

clean::
	$(RM) $(OBJPREFIX)calcapicrs

.PHONY: bin/calcapicrs install.exec

bin/calcapicrs:: $(DESTDIR)$(BINDIR)/calcapicrs

exec:: $(OBJPREFIX)calcapicrs

install.exec:: install.calcapicrs

install.calcapicrs:: $(OBJPREFIX)calcapicrs
	 if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
		else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
	$(INSTALL) $(INSTALLFLAGS) $(INSTBINFLAGS) $(OBJPREFIX)calcapicrs $(DESTDIR)$(BINDIR)/calcapicrs

# -----------------------------------------------------------------------
# common rules for all Makefiles - do not edit

.c.i:
	$(RM) $@
	$(CC) -E $(CFLAGS) $(_NOOP_) $*.c > $@
# These need to be here so that rules in Imakefile occur first;  the blank
# emptyrule is to make sure that an empty Imakefile does not default to
#  make clean.
emptyrule::

clean::
	$(RM)   *.CKP *.ln *.BAK *.bak *.o core errs ','* *~ *.a .emacs_* tags TAGS make.log MakeOut *.so *.so.*  "#"*

clean::
	-@if [ -d $(OBJPREFIX) ]; then \
		(set -x; cd $(OBJPREFIX); $(RM) *.o *.a *.so *.so.*); else exit 0; fi

Makefile::
	-@if [ -f $@ ]; then set -x; \
	$(RM) $@.bak; $(MV) $@ $@.bak; \
	else exit 0; fi
	$(IMAKE_CMD) -s - -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR) \
	             -DPackageTop=$(PACKAGETOP)	\
		     -DPackageName=$(PACKAGE_NAME) \
		      -f Imakefile | $(TR) -d '\0' > Makefile

tags::
	$(TAGS) -w *.[ch]
	$(TAGS) -xw *.[ch] > TAGS

# Principle of least surprise says that install installs the libraries.
install:: install.lib

# -----------------------------------------------------------------------
# empty rules for directories that do not have SUBDIRS - do not edit

install::
	@echo "install in $(CURRENT_DIR) done"

install.man::
	@echo "install.man in $(CURRENT_DIR) done"

install.linkkit::
	@echo "install.linkkit in $(CURRENT_DIR) done"

install.include::

install.lib::

install.exec::

Makefiles::

includes::

depend::

tags::

exec::

tree::
	@true

all::

ifeq ($(strip $(SRCS)),)
    CSRCS = $(wildcard *.[c])
    FSRCS = $(wildcard *.[F])

depend::
	$(DEPEND) $(DEPENDFLAGS) -- $(ALLDEFINES) $(DEPEND_DEFINES) --  $(CSRCS)

depend::
	$(DEPEND) -a $(DEPENDFLAGS) --  $(FORTRANALLDEFINES) $(DEPEND_DEFINES) --  $(FSRCS)

endif

# -----------------------------------------------------------------------
# dependencies generated by makedepend

