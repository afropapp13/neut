//Konosuke Iwamoto
//June 8, 2014

//DESCRIPTION:

//Script to read in muon & neutrino kinematics in text file, attach photon under certain probability

// 3/31/2014 17:43 EST - Completed radiative correction script using interpolation and integrals of 2D distributions and splines that are already made; no need to run over text file multiple times.
// 6/8/2014 17:43 EST - Completed radiative correction script using interpolation for probability density of photon as well.
// 7/8/2014  14:58 EST - Turned off FV constraint
// 7/30/2014 15:37 EST - nue rad CCQE added



#define _USE_MATH_DEFINES
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include "TROOT.h"
#include <TString.h>
#include <TMath.h>
#include <iostream>
#include <TH1D.h>
#include <TH2D.h>
#include <TGraph.h>
#include <TSpline.h>
#include <TLegend.h>
#include <TCanvas.h>
#include <TStyle.h>
#include <TRandom.h>
#include <TF1.h>
#include <TArrow.h>


class SplineEval
{
public:
    SplineEval(TSpline3* s)
    {
        spline=s;
    }
    
    double operator()(double* x, double* /*p*/)
    {
        if ((spline->Eval(x[0])) >0)
        {
            return (spline->Eval(x[0]));
        }
        else
        {
            return 0;
        }
    }
    
private:
    TSpline3* spline;
};

Double_t ProbCalCode(Double_t EP, Double_t CosTheta, double Enu1, double Enu2, Double_t ProbCal, TH2D *Hist, TH2D *HistA);
TF1* plotSP(TGraph *GRF, TSpline3 *Spl,Double_t *EGammaArray, Double_t *pArray);


void RadCorrection() //Apply radiative corrections on muon samples
{
    
    //RESETS RANDOMIZATION
    gRandom->SetSeed();
    //////////////////////
  
///////VERTEX COORDINATES Generation
//Since I did not know how to extract vertex coordinate from samples generated by neutroot, I assign vertex coordinate within FV
    
    double ver[3]; //vertex coordinate (x,y,z) of n=10000 muon samples
    
    double r_sk = 1690; //radius of SKFD in cm
    double h_sk = 3640; //height of SKFD in cm

    Double_t PI= TMath::Pi();
    
    double phi_ver; //phi of vertex coordinate
    double r_ver; //radius of vertex coordinate in cm
    double h_ver; //height used to calculate z of vertex coordinate in cm
    double r_fid = 0; //Fiducial Volume is 200cm from the surface    srand( (unsigned)time( NULL ) );
////////////////////////////////////
    
///////////////VARIABLES TO READ INPUT FILE/////////////////////

    //Buffers to name input/output filenames
    char inputname[100];
    char samplename[100];
    int z=0;
 
    //Buffers to store information read from Sample.txt
    char start[100];//begin
    char end[100];//end
    char track1[100];//track(1)
    char track2[100];//track(2)
    
    //First track
    Int_t PDG1 = 0;//PDG
    Double_t Ep1 = 0;//Energy of Particle
    Double_t dirx1, diry1, dirz1 =0;//Direction Cosine
    Int_t dirt1 = 0; //Time (=0)
    
    //Second track
    Int_t PDG2 = 0;
    Double_t Ep2 = 0;
    Double_t dirx2, diry2, dirz2 =0;
    Int_t dirt2 = 0;
    
    //Store necessary information to calculate probability, probability, and photon energy
    
    
    Double_t EpNeu=0;
    
    Double_t CosTheta = 0;
    Double_t Ephoton = 0;
    
    Double_t ProbCal = 0;
    Double_t ProbRand = 0;
    
    Double_t ProbMax = 0;
    
    
    //Maximum and minimum of integral
    double min = 0.03;
    double max = 3.5;
    
///////////////////////////////////////////////////////////////
    
//Opens necessary distributions and splines from root files
    
    TFile *MCfile = new TFile("RadnumuCCQE.root");
    TFile *MCfileE= new TFile("RadnueCCQE.root");
    
    TF1 *PDF[37][28];
    
    double EnuList[37]= {0.15, 0.175, 0.2, 0.225, 0.25, 0.275, 0.3, 0.325, 0.35, 0.375, 0.4, 0.425, 0.45, 0.55, 0.65, 0.75, 0.85, 0.95, 1.15, 1.35, 1.55, 1.75, 1.95, 2.1, 2.5, 2.9, 3.3, 3.7, 4.1, 4.75, 5.5, 6.25, 7., 7.75, 8.5, 9.25, 10.};
    
    double CtList[28]={-0.95, -0.85, -0.75, -0.65, -0.55, -0.45, -0.35, -0.25, -0.15, -0.05, 0.05, 0.15, 0.25,0.35, 0.45, 0.55, 0.65, 0.75, 0.81, 0.83, 0.85, 0.87, 0.89, 0.91, 0.93, 0.95, 0.97, 0.99};
    
    
    double EGList[24]={0.015,0.025,0.0375,0.0525,0.07,0.09,0.1125,0.1375,0.1625,0.1875,0.225,0.275,0.325,0.375,0.45,0.55,0.7,0.9,1.15,1.45,1.8,2.25,2.75,3.5};
    
    Double_t EPVal;
    
    int INTEnuA[5] = {0,13,18,24,30};
    int INTEnuB[5] = {12,17,22,28,36};
    int INTHist[5] = {0,1,2,4,6};
    
    int INTEnuIntA[6] = {12,17,22,23,28,29};
    int INTEnuIntB[6] = {13,18,23,24,29,30};
    int INTHistInt[6] = {0,1,2,3,4,5};
    
    TString numbering[7]={"0","1","2","3","4","5","6"};
    TString NMB[50]={"_1","_2","_3","_4","_5","_6","_7","_8","_9","_10","_11","_12","_13","_14","_15","_16","_17","_18","_19","_20","_21","_22","_23","_24","_25","_26","_27","_28","_29","_30","_31","_32","_33","_34","_35","_36","_37","_38","_39","_40","_41","_42","_43","_44","_45","_46","_47","_48","_49","_50"};

    
    TH2D *HistTest[7];
    TH2D *HistTestA[7];
    TH2D *HistTestInt[6];
    TH2D *HistTestIntA[6];
    
    
    TH2D *HistEP[7][24];
    TH2D *HistEPA[7][24];
    
    TH2D *HistEPInt[6][24];
    TH2D *HistEPIntA[6][24];
    
    TF1 *exmple;
    TGraph *GEXMSet=0;
    TSpline3 *SpEXMSet=0;
    
    Double_t exmplArray[24];
    
    
    for (int x = 0;x<37;x++)
    {
        for (int y =0;y<28;y++)
        {
            PDF[x][y] = new TF1(*(TF1*)MCfile->Get("PDF"+NMB[x]+NMB[y]));
        }
    }
    for (int b=0;b<7;b++)
    {
        HistTest[b]= new TH2D(*(TH2D*)MCfile->Get("Prob"+numbering[b]));
        HistTestA[b]= new TH2D(*(TH2D*)MCfile->Get("ProbA"+numbering[b]));

    }
    

    for (int c=0;c<6;c++)
    {
        HistTestInt[c]= new TH2D(*(TH2D*)MCfile->Get("ProbInt"+numbering[c]));
        HistTestIntA[c]= new TH2D(*(TH2D*)MCfile->Get("ProbIntA"+numbering[c]));

    }
    
    
    
    for (int x = 0;x<7;x++)
    {
        for (int y =0;y<24;y++)
        {
            HistEP[x][y] = new TH2D(*(TH2D*)MCfile->Get("EP"+numbering[x]+NMB[y]));
            HistEPA[x][y] = new TH2D(*(TH2D*)MCfile->Get("EPA"+numbering[x]+NMB[y]));
            
            if (x<6)
            {
                HistEPInt[x][y] = new TH2D(*(TH2D*)MCfile->Get("EPInt"+numbering[x]+NMB[y]));
                HistEPIntA[x][y] = new TH2D(*(TH2D*)MCfile->Get("EPIntA"+numbering[x]+NMB[y]));
                
            }
            
            
        }
    }
    

///////////////////////////////////////////////////////////////
    
    ///SET MAX PROB

    ProbMax = HistTestA[6]->Interpolate(10,0.99);
    
    
    
    for (z=0;z<3;z++)//ForLoop to input/output multiple text files; it is set to only read "input0.txt","input1.txt", and "input2.txt" for now
        
    {
  
    sprintf(inputname,"input%i.txt",z);
    sprintf(samplename,"mpsample%i.txt",z);
    
    FILE *finput = fopen(inputname,"r");
    FILE *foutput = fopen(samplename, "w");
    
    
    while(!feof (finput))
    {
    //Reads first sequence of entry (from "begin" to "end")
    fscanf(finput,"%s\n",start);
    fscanf(finput,"%[track]",track1);
    fscanf(finput, "%i %lf %lf %lf %lf %i\n", &PDG1, &Ep1, &dirx1, &diry1, &dirz1, &dirt1);
    fscanf(finput,"%[track]",track2);
    fscanf(finput, "%i %lf %lf %lf %lf %i\n", &PDG2, &Ep2, &dirx2, &diry2, &dirz2, &dirt2);
    fscanf(finput,"%s\n",end);
        
    //Generates random values for FV
    phi_ver = 2* PI * ((double)rand() / ((double)RAND_MAX+1));// creates random phi_ver from 0 to 2pi
    r_ver =  (r_sk - r_fid) *  ((double)rand() / ((double)RAND_MAX));// creates random r_ver from 0 to 1490cm
    h_ver = (h_sk - 2*r_fid) *  ((double)rand() / ((double)RAND_MAX));//creates random h_ver from 0 to 3240cm
      
        //X,Y,Z COORDINATES for Radius
        ver[0] = r_ver * cos(phi_ver);
        ver[1] = r_ver * sin(phi_ver);
        ver[2] = h_ver - (h_sk - 2*r_fid)/2;
        
    CosTheta = (dirx1*dirx2)+(diry1*diry2)+(dirz1*dirz2);
        EpNeu = Ep1;
    Ep1 = Ep1/1000;//Converts MeV to GeV

       
///////////////
        
    //Gets probability of generating photons using the distributions in ProbDist.root
        ProbCal = 0;
        
        if (PDG1 == 14)  //NUMU
        {
            
            if (Ep1 < EnuList[0])
            {
                ProbCal = 0;
            }
            
            for (int A=0;A<5;A++)
            {
                ProbCal = ProbCalCode(Ep1,CosTheta,EnuList[INTEnuA[A]],EnuList[INTEnuB[A]],ProbCal,Hist[INTHist[A]],HistA[INTHist[A]]);
            }
            
            for (int B=0;B<6;B++)
                
            {
                ProbCal = ProbCalCode(Ep1,CosTheta,EnuList[INTEnuIntA[B]],EnuList[INTEnuIntB[B]],ProbCal,HistInt[INTHistInt[B]],HistIntA[INTHistInt[B]]);
            }
            
            
            
            
            
            for (int C=0;C<24;C++)
            {
                for (int A=0;A<5;A++)
                {
                    EPVal = ProbCalCode(Ep1,CosTheta,EnuList[INTEnuA[A]],EnuList[INTEnuB[A]],ProbCal,HistEP[INTHist[A]][C],HistEPA[INTHist[A]][C]);
                }
                
                for (int B=0;B<6;B++)
                    
                {
                    EPVal = ProbCalCode(Ep1,CosTheta,EnuList[INTEnuIntA[B]],EnuList[INTEnuIntB[B]],ProbCal,HistEPInt[INTHistInt[B]][C],HistEPIntA[INTHistInt[B]][C]);
                }
                
                exmplArray[C] = EPVal;
                
            }
            
            
            exmple = plotSP(GEXMSet, SpEXMSet, EGList, exmplArray);
            
            
            Ephoton = exmple->GetRandom(min,max);
            
            while ((Ep2-(1000*Ephoton))<0)
            {
                Ephoton = exmple->GetRandom(min,max);
            }
            
        }
        
        
        if (PDG1 == 12) //NUE
        {
            
            
            if (Ep1 < EnuList[0])
            {
                ProbCal = 0;
            }
            
            for (int A=0;A<5;A++)
            {
                ProbCal = ProbCalCode(Ep1,CosTheta,EnuList[INTEnuA[A]],EnuList[INTEnuB[A]],ProbCal,HistE[INTHist[A]],HistEA[INTHist[A]]);
            }
            
            for (int B=0;B<6;B++)
                
            {
                ProbCal = ProbCalCode(Ep1,CosTheta,EnuList[INTEnuIntA[B]],EnuList[INTEnuIntB[B]],ProbCal,HistEInt[INTHistInt[B]],HistEIntA[INTHistInt[B]]);
            }
            
            
            
            
            
            for (int C=0;C<24;C++)
            {
                for (int A=0;A<5;A++)
                {
                    EPVal = ProbCalCode(Ep1,CosTheta,EnuList[INTEnuA[A]],EnuList[INTEnuB[A]],ProbCal,HistEEP[INTHist[A]][C],HistEEPA[INTHist[A]][C]);
                }
                
                for (int B=0;B<6;B++)
                    
                {
                    EPVal = ProbCalCode(Ep1,CosTheta,EnuList[INTEnuIntA[B]],EnuList[INTEnuIntB[B]],ProbCal,HistEEPInt[INTHistInt[B]][C],HistEEPIntA[INTHistInt[B]][C]);
                }
                
                exmplArray[C] = EPVal;
                
            }
            
            
            exmple = plotSP(GEXMSet, SpEXMSet, EGList, exmplArray);
            
            
            Ephoton = exmple->GetRandom(min,max);
            
            while ((Ep2-(1000*Ephoton))<0)
            {
                Ephoton = exmple->GetRandom(min,max);
            }
            
            
        }

        exmple=0;
        
        
        //Generates random value uniform in range [0,1], which is used for the criteria to attach photon or not
        ProbRand = gRandom->Uniform(0,1);
        
       ////////////
        
        
        if ( ProbRand <= (ProbCal/ProbMax)) //ATTACH PHOTON
            
        {

            fprintf(foutput, "%s\n", start);
            fprintf(foutput, "vertex %f %f %f %d\n",ver[0],ver[1],ver[2],0);
            fprintf(foutput, "%s %i %lf %lf %lf %lf %i\n", track2, PDG2, Ep2-(1000*Ephoton), dirx2, diry2, dirz2, dirt2);
            fprintf(foutput, "%s %i %lf %lf %lf %lf %i\n", track1, 22, Ephoton*1000, dirx2, diry2, dirz2, dirt2);
            fprintf(foutput, "%s\n", end);
            
            
        }
        else //NOT ATTACHING PHOTON
            
        {
    fprintf(foutput, "%s\n", start);
    fprintf(foutput, "vertex %f %f %f %d\n",ver[0],ver[1],ver[2],0);
    fprintf(foutput, "%s %i %lf %lf %lf %lf %i\n", track2, PDG2, Ep2, dirx2, diry2, dirz2, dirt2);
    fprintf(foutput, "%s\n", end);
        }


        
    }

    
    
    fclose(finput);
    fclose(foutput);
    }
    

}


Double_t ProbCalCode(Double_t EP, Double_t CosTheta, double Enu1, double Enu2, Double_t ProbCal, TH2D *Hist, TH2D *HistA)
//Gets probability of generating photons using the distributions in ProbDist.root
{
    
    if(EP >= Enu1 && EP < Enu2)
    {
        if(CosTheta < 0.8)
        {
            ProbCal = Hist->Interpolate(EP,CosTheta);
            
        }
        if(CosTheta > 0.8)
        {
            ProbCal = HistA->Interpolate(EP,CosTheta);
        }
    }
    
    return ProbCal;
    
}

TF1* plotSP(TGraph *GRF, TSpline3 *Spl,Double_t *EGammaArray, Double_t *pArray)

{
    GRF=new TGraph(23,EGammaArray,pArray);
    Spl= new TSpline3("",GRF);
    SplineEval* se=new SplineEval(Spl);
    TF1* f1Spline=new TF1("f1", se, 0, 3.5, 0, "SplineEval");
    return f1Spline;
}

